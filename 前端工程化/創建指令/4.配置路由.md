
```bash
npm i react-router-dom

mkdir -p src/router 
mkdir -p src/router/LazyLoad
mkdir -p src/views 

echo "import { env } from '@/api/env'

const Home = () => {
  return (
    <button
      onClick={() => {
        env(import.meta.env)
          .then((res) => {
            console.log(res.data)
          })
          .catch((err) => {
            console.error(err)
          })
      }}
      className=\"shadow-md font-bold underline \"
    >
      Hello world!
    </button>
  )
}

export default Home" > src/views/page.tsx

echo "import { Outlet } from 'react-router-dom'
import { useNavigate } from 'react-router-dom'

const Layout = () => {
  const navigate = useNavigate()
  return (
    <section className=\"flex h-screen\">
      <aside className=\"w-64 bg-gray-200\">
        <div className=\"flex flex-col items-center gap-2\">aside</div>
      </aside>
      <section className=\"flex-1 flex flex-col\">
        <header className=\"h-16 bg-blue-200 flex gap-2 items-center\">
          <div>header</div>
          <div>
            <button
              onClick={() => navigate(-1)}
              className=\"p-2 bg-gradient-to-r from-indigo-600 to-purple-800 text-white font-semibold rounded-lg shadow-md hover:opacity-75 transition duration-300 ease-in-out\"
            >
              上一頁
            </button>
          </div>
        </header>
        <main className=\"p-4 max-h-screen overflow-y-auto\">
          <Outlet />
        </main>
      </section>
    </section>
  )
}

export default Layout" > src/views/layout.tsx

echo "import { StepForwardOutlined } from '@ant-design/icons'
const meta = {
  page: {
    name: '首頁',
    label: '首頁',
    lazy: false,
    icon: StepForwardOutlined,
  },
  layout: {
    name: '控制台',
    label: '控制台',
  },
}" > src/views/meta.ts


echo '@keyframes loader-anim {
  0% {
    width: 0%;
  }

  100% {
    width: 100%;
  }
}

.animateLoader {
  animation: loader-anim 2s infinite;
}' > src/router/LazyLoad/loader.module.scss

echo "import React, { Suspense } from 'react'
import clsx from 'clsx'
import styles from './loader.module.scss'
export default function LazyLoad(
  ComponentPromise: Promise<{ default: React.ComponentType<object> }>
) {
  const LazyComponent = React.lazy(() => ComponentPromise)

  return (
    <Suspense fallback={<Loader />}>
      <LazyComponent />
    </Suspense>
  )
}

function Loader() {
  return (
    <div className=\"fixed top-0 left-0 w-full h-1 bg-gray-400\">
      <div
        className={clsx(
          'h-full bg-gradient-to-r from-green-500 to-blue-500',
          styles.animateLoader
        )}
      ></div>
    </div>
  )
}" > src/router/LazyLoad/LazyLoad.tsx

echo "import { useRoutes } from 'react-router-dom'
import { BrowserRouter } from 'react-router-dom'

import router from '@/router/router'
const Routes = () => {
  const routes = useRoutes(router)
  return routes
}

function App() {
  return (
    <BrowserRouter>
      <Routes />
    </BrowserRouter>
  )
}

export default App" > src/App.tsx

npm pkg set scripts.route="node ./src/lib/createRouter.js"

echo '/* eslint-disable @typescript-eslint/no-var-requires */
const fs = require('\''fs'\'')
const path = require('\''path'\'')

function readMeta(filePath) {
  const regex = /\/([^/]+)$/
  const match = filePath.match(regex)
  const lastSegment = match ? match[1] : null
  const metaPath = '\''../views'\'' + filePath.replace(regex, '\''/meta.ts'\'')
  return new Promise((resolve) => {
    fs.readFile(path.join(__dirname, metaPath), '\''utf8'\'', (err, data) => {
      try {
        let importString = '\'''\''

        const importRegex = /import\s.*from\s+['\''"]([^'\''"]+)['\''"]/g
        const matches = data.match(importRegex)
        if (matches && matches.length > 0) {
          matches.forEach((match) => {
            importString += match + '\''\n'\''
            data = data.replace(match, '\'''\'') // 刪除匹配的 import 語句
          })
        }
        const metaRegex = /const\s+meta\s+=\s+/
        let updatedData = data.replace(metaRegex, '\'''\'')
        const modifiedString = updatedData.replace(
          /icon:\s*([^,\n}]+)/g,
          "icon: '\''$1'\''"
        )
        const jsonMeta = eval(`(${modifiedString})`)
        const res = {
          meta: jsonMeta[lastSegment],
          importString,
        }

        resolve(res)
        // resolve(jsonMeta[lastSegment])

        resolve()
      } catch (err) {
        resolve()
      }
    })
  })
}
function findClosestLayout(directory) {
  const files = fs.readdirSync(directory)
  const hasLayout = files.includes('\''layout.tsx'\'')
  if (hasLayout) {
    return path.join(directory, '\''layout.tsx'\'')
  }
  const parentDirectory = path.dirname(directory)
  if (parentDirectory === directory || !directory.includes('\''views'\'')) {
    return '\'''\''
  }
  return findClosestLayout(parentDirectory)
}
async function printDirectoryContents(
  directory,
  parentPath = '\''/'\'',
  result = {
    arr: [],
    importString: '\'''\'',
  }
) {
  const files = fs.readdirSync(directory)
  const hasLayout = files.includes('\''layout.tsx'\'')
  const hasPage = files.includes('\''page.tsx'\'')
  const closestLayout = findClosestLayout(directory)
    .replace(path.join(__dirname, '\''../views'\''), '\'''\'')
    .replace(/\\/g, '\''/'\'')
    .replace('\''.tsx'\'', '\'''\'')
  for (const file of files) {
    const filePath = path.join(directory, file)
    const stat = fs.statSync(filePath)
    if (stat.isDirectory()) {
      const folderPath = path.join(parentPath, file)
      await printDirectoryContents(filePath, folderPath, result)
    } else {
      if (!hasLayout && !hasPage) return
      const filePath = path
        .join(parentPath, file)
        .replace(/\\/g, '\''/'\'')
        .replace('\''.tsx'\'', '\'''\'')
      if (!filePath.endsWith('\''page'\'') && !filePath.endsWith('\''layout'\'')) continue
      const fileData = await readMeta(filePath)
      const fileDataImportString = fileData?.importString || '\'''\''
      if (!result.importString.includes(fileDataImportString)) {
        result.importString += fileDataImportString
      }
      const routePathRegex = /\/\([^)]*\)/g
      const paramsRegex = /\[(\w+)\]/g
      const routePath =
        filePath
          .replace(routePathRegex, '\'''\'')
          .replace(paramsRegex, '\'':$1'\'')
          .replace(/\/(?:page|layout)/g, '\'''\'') || '\''/'\''
      const isLayout = filePath.endsWith('\''layout'\'')
      const item = {
        routePath,
        filePath,
        isLayout,
        meta: fileData?.meta ? fileData.meta : {},
        closestLayout,
      }
      if (routePath === '\''/404'\'') {
        item.routePath = '\''/*'\''
        item.closestLayout = '\'''\''
      }
      result.arr.push(item)
    }
  }
}

function parentKey(filePath, obj) {
  const keys = Object.keys(obj)
  for (let key of keys) {
    if (key === filePath) continue
    if (filePath.replace('\''/layout'\'', '\'''\'').includes(key.replace('\''/layout'\'', '\'''\''))) {
      return key
    }
  }
  return false
}

const createPathArray = async () => {
  const viewsDirectory = path.join(__dirname, '\''../views'\'')
  const result = {
    arr: [],
    importString: '\'''\'',
  }
  await printDirectoryContents(viewsDirectory, '\''/'\'', result)
  result.arr.sort((a, b) => {
    if (a.filePath === a.closestLayout && b.filePath !== b.closestLayout) {
      return -1
    } else if (
      a.filePath !== a.closestLayout &&
      b.filePath === b.closestLayout
    ) {
      return 1
    } else {
      return a.routePath.localeCompare(b.routePath)
    }
  })
  return result
}

function transform(filePath) {
  const regex = /^\(.*\)$/
  const component = filePath
    .split('\''/'\'')
    .filter((str) => !regex.test(str))
    .map((str) => {
      const result =
        str.length > 1
          ? str.slice(0, 1).toUpperCase() + str.slice(1)
          : str.toUpperCase()
      return result
    })
    .reverse()
    .join('\'''\'')

  return component
}
const createOutput = (arr, initOutputString) => {
  const map = {}
  const result = arr.reduce((acc, cur) => {
    const { routePath, filePath, closestLayout, isLayout, meta } = cur
    const isLazy = meta?.lazy === undefined ? true : meta.lazy
    const path = `@/views${filePath}`
    const component = transform(filePath)
    const isNotLazyImport = `
import ${component} from "${path}"`
    const isNotLazyComponent = `<${component}/>`
    const lazyComponent = `LazyLoad(import('\''${path}'\''))`
    const element = isLazy ? lazyComponent : isNotLazyComponent
    if (!isLazy) {
      initOutputString += isNotLazyImport
      delete meta.lazy
    }
    const item = {
      path: routePath === '\''/'\'' ? '\'''\'' : routePath,
      element,
      ...meta,
    }
    const condition = {
      isLayout: {
        true: () => {
          map[filePath] = {
            ...item,
            children: [],
          }
          const key = parentKey(filePath, map)
          if (key) {
            map[key].children.push(map[filePath])
          } else {
            acc = [...acc, map[filePath]]
          }
        },
        false: () => {
          if (!closestLayout) {
            map[routePath] = item
            acc = [...acc, map[routePath]]
          } else {
            map[closestLayout].children.push(item)
          }
        },
      },
    }
    condition.isLayout[isLayout]()
    return acc
  }, [])
  const output =
    initOutputString +
    `
const router = ${JSON.stringify(result, null, 2)
      .replace(/"LazyLoad\(.*?\)"/g, (match) => match.replace(/"/g, '\'''\''))
      .replace(/"(<[^>]+>)"/g, '\''$1'\'')
      .replace(/("icon":\s*)"([^"]*)"/g, '\''$1<$2/>'\'')}
export default router
`
  const targetFile = '\''../router/router.tsx'\''
  const targetPath = path.resolve(__dirname, targetFile)
  return { output, targetPath }
}

const createRouter = async () => {
  const { arr, importString } = await createPathArray()
  let initOutput = `import LazyLoad from "./LazyLoad/LazyLoad"\n${importString}`

  const { output, targetPath } = createOutput(arr, initOutput)

  fs.writeFileSync(targetPath, output)
}
createRouter()' > src/lib/createRouter.js

npm run route

```
